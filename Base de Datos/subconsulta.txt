-- 1. Todos los datos de clientes sin facturas

SELECT *
FROM customers
WHERE customer_id NOT IN (
	SELECT customer_id
	FROM invoices
);

-- 2. Todos los datos de vehículos sin facturas

SELECT *
FROM vehicles
WHERE vehicle_id NOT IN (
	SELECT vehicle_id
	FROM invoices
);

-- 3. Suma de horas trabajadas por Rosa

SELECT SUM(hours)
FROM items_work
WHERE mechanic_id = (
	SELECT mechanic_id
	FROM mechanics
	WHERE name LIKE '%Rosa%'
);

-- 4. Suma de importe del producto Battery EXT55

SELECT SUM(units*price)
FROM items_part
WHERE part_id = (
	SELECT part_id
	FROM parts
	WHERE description='Battery EXT55'
);

-- 5. Facturas que sólo tengan mano de obra (sin piezas)

SELECT * 
FROM invoices
WHERE invoice_id IN (
	SELECT invoice_id
	FROM items_work
)
AND invoice_id NOT IN (
	SELECT invoice_id
	FROM items_part
);

-- 6. Facturas que sólo tengan piezas (sin mano de obra)

SELECT * 
FROM invoices
WHERE invoice_id NOT IN (
	SELECT invoice_id
	FROM items_work
)
AND invoice_id IN (
	SELECT invoice_id
	FROM items_part
);

-- 7. Facturas que tengan tanto piezas como mano de obra

SELECT * 
FROM invoices
WHERE invoice_id IN (
	SELECT invoice_id
	FROM items_work
)
AND invoice_id IN (
	SELECT invoice_id
	FROM items_part
);

-- 8. Piezas que no se hayan vendido nunca

SELECT *
FROM parts
WHERE part_id NOT IN (
	SELECT part_id
	FROM items_part
);

-- 9. Número de facturas de Francesca Renatti 

SELECT COUNT(*)
FROM invoices
WHERE customer_id = (
	SELECT customer_id
	FROM customers
	WHERE name='Renatti, Francesca'
);

-- 10. Suma de importe de piezas las facturas de 'Sakata, Koji' 

SELECT SUM(units*price)
FROM items_part
WHERE invoice_id IN (
	SELECT invoice_id
	FROM invoices
	WHERE customer_id = (
		SELECT customer_id
		FROM customers
		WHERE name='Sakata, Koji'
	)
);

-- 11. Suma de importe de mano de obra de Francesca Renatti

SELECT SUM(hours*i.price_hour)
FROM items_work iw, invoices i
WHERE iw.invoice_id=i.invoice_id
AND customer_id = (
	SELECT customer_id
	FROM customers
	WHERE name='Renatti, Francesca'
);

-- 12. Número de ítems de mano de obra del vehículo 5445BBF

SELECT COUNT(*)
FROM items_work
WHERE invoice_id IN (
	SELECT invoice_id
	FROM invoices
	WHERE vehicle_id='5445BBF'
);

-- 13. Todos los datos de piezas vendidas a vehículos Renault

SELECT *
FROM parts
WHERE part_id IN (
	SELECT part_id
	FROM items_part
	WHERE invoice_id IN (
		SELECT invoice_id
		FROM invoices
		WHERE vehicle_id IN (
			SELECT vehicle_id
			FROM vehicles
			WHERE brand='Renault'
		)
	)
);

-- La clausula HAVING es a los grupos lo mismo
-- que la clausula WHERE es a las filas.
-- Es decir, pone condiciones a los grupos.
-- Las condiones se establecen sobre funciones de agregados.

-- 14. Identificadores de clientes con más de una factura

SELECT customer_id, COUNT(*)
FROM invoices
GROUP BY customer_id
HAVING COUNT(*)>1;

-- 15. Identificadores de piezas con suma de unidades vendidas
-- mayor que 4

SELECT part_id, SUM(units)
FROM items_part
GROUP BY part_id
HAVING SUM(units)>4;

-- 16. Identificadores de mecánicos con suma de horas mayor que 5

SELECT mechanic_id, SUM(hours)
FROM items_work
GROUP BY mechanic_id
HAVING SUM(hours)>5;

-- 17. Identificadores de mecánicos con suma de horas
-- superior a la suma de Michael Kurtiss

SELECT mechanic_id, SUM(hours)
FROM items_work
GROUP BY mechanic_id
HAVING SUM(hours)>(
	SELECT SUM(hours)
	FROM items_work
	WHERE mechanic_id=(
		SELECT mechanic_id
		FROM mechanics
		WHERE name='Kurtiss, Michael'
	)
);

-- El operador ALL se utiliza con los operadores > < >= <=
-- Se compara el valor de la izquierda con todos los valores de la derecha

-- 18. Todos los datos del mecánico que más horas trabajada

SELECT m.mechanic_id, m.name, m.phone, SUM(i.hours)
FROM mechanics m, items_work i
WHERE m.mechanic_id=i.mechanic_id
GROUP BY m.mechanic_id, m.name, m.phone
HAVING SUM(i.hours)>= ALL (
	SELECT SUM(hours)
	FROM items_work
	GROUP BY mechanic_id
);

-- 19. Todos los datos de la pieza con más suma de unidades vendidas

SELECT p.part_id, p.description, p.price, SUM(i.units)
FROM parts p, items_part i
WHERE p.part_id=i.part_id
GROUP BY p.part_id, p.description, p.price
HAVING SUM(i.units)>= ALL (
	SELECT SUM(units)
	FROM items_part
	GROUP BY part_id
);

-- 20. Todos los datos del cliente con más facturas

SELECT c.customer_id, c.name, COUNT(*)
FROM customers c, invoices v
WHERE c.customer_id=v.customer_id
GROUP BY  c.customer_id, c.name
HAVING COUNT(*) >= ALL (
	SELECT COUNT(*)
	FROM invoices
	GROUP BY customer_id
);

-- 21. Todos los datos del vehículo con más facturas

SELECT v.vehicle_id, v.brand, v.model, COUNT(*)
FROM vehicles v, invoices i
WHERE v.vehicle_id=i.vehicle_id
GROUP BY v.vehicle_id, v.brand, v.model
HAVING COUNT(*) >= ALL (
	SELECT COUNT(*)
	FROM invoices
	GROUP BY vehicle_id
);

-- 22. Todos los datos de la marca de vehículos con más facturas

SELECT v.brand, COUNT(*)
FROM vehicles v, invoices i
WHERE v.vehicle_id=i.vehicle_id
GROUP BY v.brand
HAVING COUNT(*) >= ALL (
	SELECT COUNT(*)
	FROM vehicles v, invoices i
	WHERE v.vehicle_id=i.vehicle_id
	GROUP BY v.brand
);

-- 23. Todos los datos del cliente con más ítems de mano de obra
-- Se mostrará además el número de facturas

SELECT c.*, COUNT(DISTINCT i.invoice_id) AS num_invoices, COUNT(*) AS num_items
FROM customers c, invoices i, items_work iw
WHERE c.customer_id=i.customer_id AND i.invoice_id=iw.invoice_id
GROUP BY c.customer_id, c.name, c.email, c.city
HAVING COUNT(*) >= ALL (
	SELECT COUNT(*)
	FROM invoices i, items_work iw
	WHERE i.invoice_id=iw.invoice_id
	GROUP BY i.customer_id
);
--24- Para cada identificador de cliente, el identificador del producto mas caro
SELECT*
FROM invoices i1,items_part ip1
WHERE i.invoice_id=ip.invoice_id
AND ipl.price >= ALL(
	SELECT ip2.pr
	FROM invoices i2,items_part ip2
	WHERE i2.invoice_id=ip2.invoice_id
	AND i1.customer_id=i2.customer_id
);

--25. Añadir a lo anterior todos los datos del cliente
SELECT c.*,ip1.part_id,ip1.price
FROM customer c,invoices i1,items_part ip1
WHERE c.customer_id=i1.invoice_id
AND ipl.price >= ALL(
	SELECT ip2.pr
	FROM invoices i2,items_part ip2
	WHERE i2.invoice_id=ip2.invoice_id
	AND i1.customer_id=i2.customer_id
);

-- 26. Añadir a lo anterior la descripción de la pieza

SELECT c.*, ip1.part_id, ip1.price, p.description
FROM customers c, invoices i1, items_part ip1, parts p
WHERE c.customer_id=i1.customer_id
AND i1.invoice_id=ip1.invoice_id
AND ip1.part_id=p.part_id
AND ip1.price >= ALL (
	SELECT ip2.price
	FROM invoices i2, items_part ip2
	WHERE i2.invoice_id=ip2.invoice_id
	AND i1.customer_id=i2.customer_id  -- Correlación
);

-- 27. Para cada identificador de vehículo, máximo importe de ítem de mano de obra

SELECT i1.vehicle_id, i1.price_hour*iw1.hours
FROM invoices i1, items_work iw1
WHERE i1.invoice_id=iw1.invoice_id
AND i1.price_hour*iw1.hours >= ALL (
	SELECT i2.price_hour*iw2.hours
	FROM invoices i2, items_work iw2
	WHERE i2.invoice_id=iw2.invoice_id
	AND i1.vehicle_id=i2.vehicle_id
);

-- 28. Añadir a lo anterior la marca y modelo del vehículo

SELECT i1.vehicle_id, v.brand, v.model, i1.price_hour*iw1.hours
FROM vehicles v, invoices i1, items_work iw1
WHERE v.vehicle_id=i1.vehicle_id
AND i1.invoice_id=iw1.invoice_id
AND i1.price_hour*iw1.hours >= ALL (
	SELECT i2.price_hour*iw2.hours
	FROM invoices i2, items_work iw2
	WHERE i2.invoice_id=iw2.invoice_id
	AND i1.vehicle_id=i2.vehicle_id
);

-- 29. Para cada cliente (que salgan todos), todos sus datos y número de facturas

SELECT c.customer_id, c.name, c.email, c.city, COUNT(i.invoice_id)
FROM customers c LEFT JOIN invoices i ON c.customer_id=i.customer_id
GROUP BY c.customer_id, c.name, c.email, c.city;

-- 30. Para cada vehículo (que salgan todos), todos sus datos y número de facturas

SELECT v.*, COUNT(i.invoice_id)
FROM vehicles v LEFT JOIN invoices i
ON v.vehicle_id=i.vehicle_id
GROUP BY v.vehicle_id, v.brand, v.model;

-- 31. Para cada mecánico (que salgan todos), número de ítems de mano de obra,
-- suma de horas y número de facturas

SELECT m.*, COUNT(DISTINCT iw.invoice_id) AS num_invoices,
COUNT(iw.mechanic_id) AS num_items, SUM(IFNULL(iw.hours,0)) AS sum_hours
FROM mechanics m LEFT JOIN items_work iw
ON m.mechanic_id=iw.mechanic_id
GROUP BY m.mechanic_id,m.name,m.phone;

-- 32. Para cada pieza (que salgan todas), número de ítems, suma de importe
-- y número de facturas

SELECT p.*, COUNT(DISTINCT ip.invoice_id) AS num_invoices,
COUNT(ip.part_id) AS num_items, SUM(IFNULL(ip.units*ip.price,0)) AS sum_import
FROM parts p LEFT JOIN items_part ip
ON p.part_id=ip.part_id
GROUP BY p.part_id, p.description, p.price;

-- 33. Left join de customers, invoices e items_part

SELECT *
FROM customers c LEFT JOIN invoices i ON c.customer_id=i.customer_id
LEFT JOIN items_part ip ON i.invoice_id=ip.invoice_id;

-- 34. La consulta anterior agruparla por cliente y contar el número de
-- facturas, el número de ítems y la suma de importe de ítems

SELECT c.*, COUNT(DISTINCT i.invoice_id) AS num_invoices,
COUNT(ip.item_part_id) AS num_items, 
SUM(IFNULL(ip.units*ip.price,0)) AS sum_import
FROM customers c LEFT JOIN invoices i ON c.customer_id=i.customer_id
LEFT JOIN items_part ip ON i.invoice_id=ip.invoice_id
GROUP BY c.customer_id, c.name, c.email, c.city;

-- 35. Para cada cliente (que salgan todos) todos sus datos, número de
-- facturas, número de ítems de mano de obra y suma de importe de mano de obra

SELECT c.*, COUNT(DISTINCT i.invoice_id) AS num_invoices,
COUNT(iw.item_work_id) AS num_items, 
SUM(IFNULL(iw.hours*i.price_hour,0)) AS sum_import
FROM customers c LEFT JOIN invoices i ON c.customer_id=i.customer_id
LEFT JOIN items_work iw ON i.invoice_id=iw.invoice_id
GROUP BY c.customer_id, c.name, c.email, c.city;

--43.Para cada producto (que salgan todos), todos sus datos, y importe facturado, y porcentaje de importe facturado respecto al importe total

SELECT p.*, IFNULL(s.sum_part,0), 
ROUND(IFNULL(s.sum_part,0)/r.sum_total*100,2) AS porc_part
FROM parts p
LEFT JOIN (
	SELECT part_id, SUM(units*price) AS sum_part
	FROM items_part
	GROUP BY part_id
) s ON p.part_id=s.part_id, (
	SELECT SUM(units*price) AS sum_total
	FROM items_part
) r;

--44.Para cada mecanico (que salgan todos), todos sis datos, importe facurado y porcentaje de importe respecto al importe total 

SELECT m.*, IFNULL(s.sum_mec,0) AS sum_mec, 
ROUND(IFNULL(s.sum_mec,0)/r.sum_total*100,2) AS porc_mec
FROM mechanics m
LEFT JOIN (
	SELECT mechanic_id, SUM(hours) AS sum_mec
	FROM items_work
	GROUP BY mechanic_id
) s ON m.mechanic_id=s.mechanic_id, (
	SELECT SUM(hours) AS sum_total
	FROM items_work
) r;



---------------------------------------------------------------
-- 1. Todos los datos de las provincias de Andalucía

SELECT *
FROM provinces
WHERE region_id=(
	SELECT region_id
	FROM regions
	WHERE name='Andalucía'
);

-- 2. Todos los datos de las provincias por donde pasa el Guadalquivir

SELECT *
FROM provinces
WHERE province_id IN (
	SELECT province_id
	FROM pro_riv
	WHERE river_id=(
		SELECT river_id
		FROM rivers
		WHERE name='Guadalquivir'
	)
);

-- 3. Todos los datos de la provincia con más población

SELECT *
FROM provinces
WHERE population=(
	SELECT MAX(population)
	FROM provinces
);

-- 4. Todos los datos de la provincia andaluza con más población

SELECT *
FROM provinces
WHERE population=(
	SELECT MAX(population)
	FROM provinces
	WHERE region_id=(
		SELECT region_id
		FROM regions
		WHERE name='Andalucía'
	)
)
AND region_id=(
	SELECT region_id
	FROM regions
	WHERE name='Andalucía'
);

-- 5. Todos los datos de provincias aragonesas por las que pasa el Ebro

SELECT *
FROM provinces
WHERE region_id=(
	SELECT region_id
	FROM regions
	WHERE name='Aragón'
)
AND province_id IN (
	SELECT province_id
	FROM pro_riv
	WHERE river_id=(
		SELECT river_id
		FROM rivers
		WHERE name='Ebro'
	)
);

-- 6. Todos los datos de provincias andaluzas con densidad
-- superior a la media de España

SELECT *
FROM provinces
WHERE region_id=(
	SELECT region_id
	FROM regions
	WHERE name='Andalucía'
)
AND population/surface>(
	SELECT AVG(population/surface)
	FROM provinces
);

-- 7. Provincias de los Pirineos

SELECT *
FROM provinces
WHERE province_id IN (
	SELECT province_id
	FROM pro_mou
	WHERE mountain_id = (
		SELECT mountain_id
		FROM mountains
		WHERE name='Pirineos'
	)
);

-- 8. Provincias andaluzas atravesadas por el Sistema Penibético

SELECT *
FROM provinces
WHERE region_id=(
	SELECT region_id
	FROM regions
	WHERE name='Andalucía'
)
AND province_id IN (
	SELECT province_id
	FROM pro_mou
	WHERE mountain_id = (
		SELECT mountain_id
		FROM mountains
		WHERE name='Sistema Penibético'
	)
); 

-- 9. Provincias Gallegas no atravesadas por el río Miño

SELECT *
FROM provinces
WHERE region_id=(
	SELECT region_id
	FROM regions
	WHERE name='Galicia'
)
AND province_id NOT IN (
	SELECT province_id
	FROM pro_riv
	WHERE river_id = (
		SELECT river_id
		FROM rivers
		WHERE name='Miño'
	)
);

-- 10. Ríos más largos que el Guadiana

SELECT *
FROM rivers
WHERE length > (
	SELECT length
	FROM rivers
	WHERE name='Guadiana'
);

-- 11. Provincias con población superior a la población de Extremadura

SELECT *
FROM provinces
WHERE population > (
	SELECT SUM(population)
	FROM provinces
	WHERE region_id = (
		SELECT region_id
		FROM regions
		WHERE name='Extremadura'
	)
);

-- 12. Montañas con altura superior a la media

SELECT *
FROM mountains
WHERE height > (
	SELECT AVG(height)
	FROM mountains
);

-- 13. Provincias con menos superficie que la mínima de la 
-- superficie de las provincias catalanas

SELECT *
FROM provinces
WHERE surface < (
	SELECT MIN(surface)
	FROM provinces
	WHERE region_id = (
		SELECT region_id
		FROM regions
		WHERE name='Cataluña'
	)
);

-- 14. Región con mayor número de provincias

SELECT r.*, COUNT(*)
FROM regions r, provinces p
WHERE r.region_id=p.region_id
GROUP BY r.region_id, r.name
HAVING COUNT(*) >= ALL (
	SELECT COUNT(*)
	FROM provinces
	GROUP BY region_id
);

-- 15. Región con mayor población

SELECT r.*, SUM(population)
FROM regions r, provinces p
WHERE r.region_id=p.region_id
GROUP BY r.region_id, r.name
HAVING SUM(population) >= ALL (
	SELECT SUM(population)
	FROM provinces
	GROUP BY region_id
);

-- 16. Todos los datos de las provincias donde desemboca el Guadalquivir

SELECT *
FROM provinces
WHERE province_id IN (
	SELECT province_id
	FROM pro_riv pr, rivers r
	WHERE pr.river_id=r.river_id
	AND r.name='Guadalquivir'
	AND pr.river_order >= ALL (
		SELECT pr.river_order
		FROM pro_riv pr, rivers r
		WHERE pr.river_id=r.river_id
		AND r.name='Guadalquivir'
	)
);

-- 17. Regiones con menor superficie que Andalucía

SELECT *
FROM regions
WHERE region_id IN (
	SELECT region_id
	FROM provinces
	GROUP BY region_id
	HAVING SUM(surface) < (
		SELECT SUM(surface)
		FROM provinces
		WHERE region_id = (
			SELECT region_id
			FROM regions
			WHERE name='Andalucía'
		)
	)
);

-- 18. Lo mismo de antes pero que se vea la superficie de cada región

SELECT r.region_id, r.name, SUM(surface)
FROM regions r, provinces p
WHERE r.region_id=p.region_id
GROUP BY r.region_id, r.name
HAVING SUM(surface) < (
	SELECT SUM(surface)
	FROM provinces
	WHERE region_id = (
		SELECT region_id
		FROM regions
		WHERE name='Andalucía'
	)
);
	
-- 19. Ríos que atraviesen menos provincias que el Gualdalquivir

SELECT r.river_id, r.name, COUNT(*)
FROM rivers r, pro_riv pr
WHERE r.river_id=pr.river_id
GROUP BY r.river_id, r.name
HAVING COUNT(*) < (
	SELECT COUNT(*)
	FROM pro_riv
	WHERE river_id = (
		SELECT river_id
		FROM rivers
		WHERE name='Guadalquivir'
	)
);

-- El orden de las clausulas es SELECT-FROM-WHERE-GROUP-HAVING

-- 20. Para cada identificador de río, número de provincias andaluzas que atraviesa

SELECT river_id, COUNT(*)
FROM pro_riv
WHERE province_id IN (
	SELECT province_id
	FROM provinces
	WHERE region_id = (
		SELECT region_id
		FROM regions
		WHERE name='Andalucía'
	)
)
GROUP BY river_id;

-- 21. Identificador del río que más provincias andaluzas atraviesa

SELECT river_id, COUNT(*)
FROM pro_riv
WHERE province_id IN (
	SELECT province_id
	FROM provinces
	WHERE region_id = (
		SELECT region_id
		FROM regions
		WHERE name='Andalucía'
	)
)
GROUP BY river_id
HAVING COUNT(*) >= ALL (
	SELECT COUNT(*)
	FROM pro_riv
	WHERE province_id IN (
		SELECT province_id
		FROM provinces
		WHERE region_id = (
			SELECT region_id
			FROM regions
			WHERE name='Andalucía'
		)
	)
	GROUP BY river_id
);

-- Data Definition Language (DDL): CREATE
-- Data Manipulation Language (DML): SELECT, INSERT, UPDATE, DELETE

-- CREATE VIEW es un comando DDL que crea una vista con los datos de una consulta.
-- Una vista es una tabla virtual que puede ser utilizada como una tabla real.
-- Los datos de la vista se extraen de otras tablas o vistas.

-- 22. Crear una vista con las provincias andaluzas

CREATE VIEW and_provinces AS
SELECT *
FROM provinces
WHERE region_id = (
	SELECT region_id
	FROM regions
	WHERE name='Andalucía'
);

-- 23. Para cada identificador de río, número de provincias andaluzas que atraviesa

SELECT river_id, COUNT(*)
FROM pro_riv
WHERE province_id IN (
	SELECT province_id
	FROM and_provinces
)
GROUP BY river_id;

-- 24. Identificador del río que más provincias andaluzas atraviesa

SELECT river_id, COUNT(*)
FROM pro_riv
WHERE province_id IN (
	SELECT province_id
	FROM and_provinces
)
GROUP BY river_id
HAVING COUNT(*) >= ALL (
	SELECT COUNT(*)
	FROM pro_riv
	WHERE province_id IN (
		SELECT province_id
		FROM and_provinces
	)
	GROUP BY river_id
);
--27. Para cada identifiacador de rio, identificador de laprovincia donde desemboca
SELECT*
FROM pro_riv pr1
WHERE river_order =(
	SELECT MAX(river.order)
	FROM pro_riv pr2
	WHERE pr1.river_id=pr2.river_id
);

--28. Añadir a lo anterior los nombres de rios y de provincias
SELECT r.name,p.name
FROM pro_riv pr1, provinces p, rivers r
WHERE p.province_id=pr1.province_id AND pr1.river_id=r.river_id 
AND river_order=(
	SELECT MAX(river.order)
	FROM pro_riv pr2
	WHERE pr1.river_id=pr2.river_id
);

--29.Para cada region, su nombre y todos los datos de su cordilllera mas alta

SELECT r1.name, ml.*
FROM regions r1,provinces p1,pro_mou pr1,mountains ml
WHERE r1.region_id=p1.region_id AND p1.province_id=pr1.province_id
AND pr1.mountain_id=m1.mountain_id
AND m1.height =(
	SELECT MAX(m2.height)
	FROM provinces p2,pro_mou pr2,mountains m2
	WHERE p2.province_id=pr2.province_id
	AND pr2.mountain_id=m2.mountain_id
	AND p1.region_id=p2.region_id
);
 
-- 30. Para cada cordillera, todos sus datos junto con una columna que tome
-- los siguientes valores:
-- -- 1000 para altura máxima inferior a 1000
-- -- 2000 para altura máxima inferior a 2000
-- -- 3000 para altura máxima inferior a 3000
-- -- 4000 para altura máxima inferior a 4000

SELECT *,	IF(height<1000,1000,
				IF(height<2000,2000,
					IF(height<3000,3000,4000)))
FROM mountains;

----------------------------------------------------------
-------------- Subconsultas en FROM-----------------------
----------------------------------------------------------
-- En la clausura FROM puede usarse una subconsulta entre parentesis en lugar de una tabla o vista 

--Densidad de poblacion de las provincias con mayor densidad que huelva

SELECT *,population/surface AS densidad
FROM (
	SELECT population/surface AS densidad_huelva
	FROM provinces
	WHERE name='Huelva') dh,
provinces;

--Es como si fuera
SELECT *,population/surface AS densidad
FROM dh,provinces;


--32.Rio gallego mas largo y rio andaluz mas largo

SELECT name
FROM rivers
WHERE length=(
	SELECT MAX(length)
	FROM rivers
	WHERE river_id IN(
		SELECT river_id
		FROM pro_riv
		WHERE province_id IN(
			SELECT province_id
			FROM regions
			WHERE name='Galicia'
			)
		)
AND length =(
			SELECT name
			FROM rivers
			WHERE length=(
	SELECT MAX(length)
	FROM rivers
	WHERE river_id IN(
		SELECT river_id
		FROM pro_riv
		WHERE province_id IN(
			SELECT province_id
			FROM regions
			WHERE name='Andaluz'
			
			)
		)
	)

--33.Rio andaluz y rio gallego mas largo 

SELECT*
FROM () s1,() s2;

--34.Porcentaje de poblacion de cada provincia respecto a la poblacion total de España
--La  poblacion total de españa

--La poblacion de España 

SELECT SUM(population)
FROM provinces;

--El porcentaje por provincia

SELECT*,population/45210755*100 AS porcentaje
FROM provinces;

-- Con una subconsulta en FROM

SELECT *, population/sum_españa*100 AS porcentaje
FROM provinces,(
	SELECT SUM(population) AS sum_españa
	FROM provincias
) vl;

--35.Todas las parejas de provincias tal que la primera povincia sea mayor en superficie  que la segunda provincia

Huelva, Sevilla no sale
Sevilla, Huelva si sale

--36.Porcentaje de poblacion de cada provincia respecto a la poblacion total de su comunidad autonoma


-- 1. Todos los datos de los libros de Cervantes

SELECT *
FROM books
WHERE book_id IN (
	SELECT book_id
	FROM boo_aut
	WHERE author_id = (
		SELECT author_id
		FROM authors
		WHERE name LIKE '%Cervantes%'
	)
);

-- 2. Todos los datos de los libros que no traten de informática

SELECT *
FROM books
WHERE book_id NOT IN (
	SELECT book_id
	FROM boo_the
	WHERE theme_id = (
		SELECT theme_id
		FROM themes
		WHERE name='Computing'
	)
);

-- 2. Para cada identificador de libro, número de veces que se prestó

SELECT c.book_id, COUNT(*) 
FROM copies c, loans l
WHERE c.copy_id=l.copy_id
GROUP BY c.book_id;

-- 3. Identificador del libro que más veces ha sido prestado

SELECT c.book_id, COUNT(*) 
FROM copies c, loans l
WHERE c.copy_id=l.copy_id
GROUP BY c.book_id
HAVING COUNT(*) >= ALL (
	SELECT COUNT(*) 
	FROM copies c, loans l
	WHERE c.copy_id=l.copy_id
	GROUP BY c.book_id
);

-- 5. Todos los datos del socio que más préstamos hizo

SELECT m.member_id, m.name, m.email, m.phone, COUNT(*)
FROM members m, loans l
WHERE m.member_id=l.member_id
GROUP BY m.member_id, m.name, m.email, m.phone
HAVING COUNT(*) >= ALL (
	SELECT COUNT(*)
	FROM loans
	GROUP BY member_id
);

-- 6. Todos los datos del tema que más libros tiene

SELECT t.theme_id, t.name, COUNT(*)
FROM boo_the bt, themes t
WHERE bt.theme_id=t.theme_id
GROUP BY t.theme_id, t.name
HAVING COUNT(*) >= ALL (
	SELECT COUNT(*)
	FROM boo_the
	GROUP BY theme_id
);

-- 7. Duración en días de cada préstamo

SELECT *, TIMESTAMPDIFF(DAY,init_date,end_date)
FROM loans;

-- La función IFNULL tiene dos parámetros:
-- -- Valor1 que puede ser nulo o no
-- -- Valor2 que devuelve si valor1 es nulo

-- 8. Todos los datos de los préstamos junto con una 
-- columna que indique se está devuelto o no

SELECT *, IFNULL(end_date,'No devuelto') AS micolumna
FROM loans;

-- 9. Duración en días de cada préstamo tomando la fecha actual para
-- los préstamos no devueltos

SELECT *, TIMESTAMPDIFF(DAY,init_date,IFNULL(end_date,CURRENT_DATE()))
FROM loans;

-- La función IF tiene tres parámetros:
-- -- Condición, donde se pueden usar columnas y operadores relacionales y lógicos
-- -- Valor devuelto si la condición es verdadera
-- -- Valor devuelto si la condición es falsa

-- 10. A la consulta anterior le añadimos una columna que indique si el préstamo
-- está devuelto o pendiente de devolución

SELECT *, TIMESTAMPDIFF(DAY,init_date,IFNULL(end_date,CURRENT_DATE())) AS dias,
IF(end_date IS NULL,'Pendiente','Devuelto') AS estado
FROM loans;

-- 11. Todos los datos de los libros junto con una columna que muestre lo siguiente:
-- -- 'Muy corto' para páginas menor que 100
-- -- 'Corto' para páginas menor que 200
-- -- 'Medio' para páginas menor que 300
-- -- 'Largo' para páginas menor que 400
-- -- 'Muy largo' para el resto

SELECT *, IF(pages<100,'Muy corto',
			IF(pages<200,'Corto',
				IF(pages<300,'Medio',
					IF(pages<400,'Largo','Muy largo')))) AS longitud
FROM books;

-- 12. Todos los datos de libros de informática que no se hayan prestado nunca

SELECT * 
FROM books
WHERE book_id IN (
	SELECT book_id
	FROM boo_the
	WHERE theme_id = (
		SELECT theme_id
		FROM themes
		WHERE name='Computing'
	)
)
AND book_id NOT IN (
	SELECT book_id
	FROM copies
	WHERE copy_id IN (
		SELECT copy_id
		FROM loans
	)
);

-- Funciones de fecha-hora:
-- HOUR(fecha)
-- MINUTE(fecha)
-- DAY(fecha)
-- MONTH(fecha)
-- YEAR(fecha)

-- 13. Todos los datos de los préstamos junto con la estación del año en que se hicieron

SELECT *, 
	IF(MONTH(init_date)=12 AND DAY(int_date)>=21 
	OR MONTH(init_date) IN (1,2)
	OR MONTH(init_date)=3 AND DAY(init_date)<=20,'Invierno',
		IF (MONTH(init_date)=3 AND DAY(init_date)>=21
		OR MONTH(init_date) IN (4,5)
		OR MONTH(init_date)=6 AND DAY(init_date)<=20,'Primavera',
			IF (MONTH(init_date)=6 AND DAY(init_date)>=21
			OR MONTH(init_date) IN (7,8)
			OR MONTH(init_date)=9 AND DAY(init_date)<=20,'Verano','Otoño'))) AS estacion
FROM loans;
			
-- 14. Todos los datos de las copias de libros de Cervantes

SELECT *
FROM copies
WHERE book_id IN (
	SELECT book_id
	FROM boo_aut
	WHERE author_id = (
		SELECT author_id
		FROM authors
		WHERE name LIKE '%Cervantes Saavedra%'
	)
);

-- 15. Todos los datos de las copias de libros de bases de datos


-- Subconsultas en la clausula WHERE
-- Permitem establecer una condición usando datos de otra tabla
-- sin necesidad de hacer equijoin.
-- Los datos de la subconsulta pueden ser una fila o un conjunto
-- de filas.

SELECT *
FROM copies
WHERE book_id IN (
	SELECT book_id
	FROM boo_the
	WHERE theme_id = (
		SELECT theme_id
		FROM themes
		WHERE name='Database'
	)
);

-- 16. Para cada autor, su libro con más páginas (correlacionada)

SELECT *
FROM authors a1, boo_aut ba1, books b1
WHERE a1.author_id=ba1.author_id AND ba1.book_id=b1.book_id
AND b1.pages = (
	SELECT MAX(b2.pages)
	FROM boo_aut ba2, books b2
	WHERE ba2.book_id=b2.book_id
	AND a1.author_id=ba2.author_id  -- Correlación
);

-- 17. Para cada identificador de socio, su primer préstamo

SELECT *
FROM loans l1
WHERE init_date = (
	SELECT MIN(init_date)
	FROM loans l2
	WHERE l1.member_id=l2.member_id  -- Correlación
);

-- 18. Añadir a lo anterior el nombre del socio

SELECT l1.*, m.name
FROM loans l1, members m
WHERE l1.member_id=m.member_id
AND init_date = (
	SELECT MIN(init_date)
	FROM loans l2
	WHERE l1.member_id=l2.member_id  -- Correlación
);

-- 19. Para cada libro (que salgan todos), todos sus datos, número de copias,
-- y número de préstamos

SELECT b.*, COUNT(DISTINCT c.copy_id) AS num_copies, COUNT(l.loan_id) AS num_loans
FROM books b LEFT JOIN copies c ON b.book_id=c.book_id
LEFT JOIN loans l ON c.copy_id=l.copy_id
GROUP BY b.book_id, b.title, b.language, b.pages, b.publisher;

-- 20. Para cada socio (que salgan todos), todos sus datos, número de préstamos
-- y número de copias
SELECT m.*, COUNT(loan_id),COUNT(DISTINCT copy_id)
FROM members m LEFT JOIN loans ON m.member_id=l.member_id
GROUP BY m.member_id,m.name,m.email,m.phone;

--21.Para cada autor (que salgan todos), todos sus datos, numero de prestamos y numero de copias distintas

--22.Añadir a lo anterior el numero de prestamos
SELECT a.* COUNT(DISTINCT b.book_id) AS num_books, COUNT(DISTINCT c.copy_id)
COUNT(l.loan_id) AS num_loans
FROM authors a
LEFT JOIN boo_aut ba ON a.author_id=ba.author_id
LEFT JOIN books b ON ba.book_id=b.book_id
LEFT JOIN copies c ON b.book_id=c.book_id
LEFT JOIN loans l ON c.copy_id=l.copy_id
GROUP BY a.author_id, a.name, a.born_date,a.death_date

--23. Para cada tema, numero de libros, numero de copias y numero de prestamos

SELECT t.theme_id, t.name 
COUNT(DISTINCT bt.book_id) AS num_books,
COUNT(DISTINCT c.copy_id)AS num_copies,
COUNT(DISTINCT l.loan_id) AS num_loans
FROM themes t
LEFT JOIN boo_the bt ON 


-- 1. Todas las películas de Paramount Pictures

SELECT m.*
FROM movies m, studios s
WHERE m.studio_id=s.studio_id
AND s.name='Paramount pictures';

-- 2. Lo mismo mediante una subconsulta que devuelve una fila

SELECT * 
FROM movies
WHERE studio_id=(
	SELECT studio_id
	FROM studios
	WHERE name='Paramount pictures'
);

-- 3. Todas las películas dirigidas por Clint Eastwood

SELECT m.*
FROM movies m, artists a
WHERE m.director_id=a.artist_id
AND a.name='Clint Eastwood';

-- 4. Lo mismo mediante una subconsulta que devuelve una fila

SELECT *
FROM movies
WHERE director_id=(
	SELECT artist_id
	FROM artists
	WHERE name='Clint Eastwood'
);

-- 5. Identificadores de las películas donde actúa Al Pacino

SELECT movie_id
FROM art_mov
WHERE artist_id=(
	SELECT artist_id
	FROM artists
	WHERE name='Al Pacino'
);

-- 6. Todos los datos de las películas donde actúa Al Pacino

SELECT *
FROM movies
WHERE movie_id IN (
	SELECT movie_id
	FROM art_mov
	WHERE artist_id=(
		SELECT artist_id
		FROM artists
		WHERE name='Al Pacino'
	)
);

-- Cuando la subconsulta devuelve varias filas no se puede usar
-- el operador = y se usa en su lugar el operador IN

-- 7. Todos los datos del director de Million dollar baby

SELECT *
FROM artists
WHERE artist_id = (
	SELECT director_id
	FROM movies
	WHERE title='Million dollar baby'
);

-- 8. Todos los datos de los actores de Million dollar baby

SELECT *
FROM artists
WHERE artist_id IN (
	SELECT artist_id
	FROM art_mov
	WHERE movie_id = (
		SELECT movie_id
		FROM movies
		WHERE title='Million dollar baby'
	)
);

-- 9. Todos los datos de los estudios para los que haya actuado Robert de Niro

SELECT *
FROM studios
WHERE studio_id IN (
	SELECT studio_id
	FROM movies
	WHERE movie_id IN (
		SELECT movie_id
		FROM art_mov
		WHERE artist_id = (
			SELECT artist_id
			FROM artists
			WHERE name='Robert de Niro'
		)
	)
);

-- 10. Todos los datos de la película más antigua

SELECT *
FROM movies
WHERE release_year=(
	SELECT MIN(release_year)
	FROM movies
);

-- 11. Todos los datos del artista más joven

SELECT *
FROM artists
WHERE born_date=(
	SELECT MAX(born_date)
	FROM artists
);

-- 12. Todos los datos de la película más antigua usando ALL

SELECT *
FROM movies
WHERE release_year <= ALL (
	SELECT release_year
	FROM movies
);

-- 13. Todos los datos del artista más joven usando ALL

SELECT *
FROM artists
WHERE born_date >= ALL (
	SELECT born_date
	FROM artists
);

-- 14. Artistas que no actuaron en 'The Godfather I' ni en 'The Godfather II'

SELECT *
FROM artists
WHERE artist_id NOT IN (
	SELECT artist_id
	FROM art_mov
	WHERE movie_id IN (
		SELECT movie_id
		FROM movies
		WHERE title IN ('The Godfather I','The Godfather II')
	)
);

-- 15. Años entre la primera y la última película donde actúa Al Pacino

SELECT MAX(release_year)-MIN(release_year)
FROM movies
WHERE movie_id IN (
	SELECT movie_id
	FROM art_mov
	WHERE artist_id = (
		SELECT artist_id
		FROM artists
		WHERE name='Al Pacino'
	)
);

-- 16. Identificador del estudio con más películas

SELECT studio_id, COUNT(*)
FROM movies
GROUP BY studio_id
HAVING COUNT(*) >= ALL (
	SELECT COUNT(*)
	FROM movies
	GROUP BY studio_id
);

-- 17. Todos los datos del estudio con más películas

SELECT s.*, COUNT(*)
FROM studios s, movies m
WHERE s.studio_id=m.studio_is
GROUP BY s.studio_id, s.name, s.fund_year
HAVING COUNT(*) >= ALL (
	SELECT COUNT(*)
	FROM movies
	GROUP BY studio_id
);

-- 18. Identificador del artista que actuó en más películas

SELECT artist_id, COUNT(*)
FROM art_mov
GROUP BY  artist_id
HAVING COUNT(*) >= ALL (
	SELECT COUNT(*)
	FROM art_mov
	GROUP BY  artist_id
);

-- 19. Todos los datos del artista que actuó en más películas

SELECT a.*, COUNT(*)
FROM artists a, art_mov am
WHERE a.artist_id=am.artist_id
GROUP BY a.artist_id, a.name, a.country, a.born_date
HAVING COUNT(*) >= ALL (
	SELECT COUNT(*)
	FROM art_mov
	GROUP BY  artist_id
);

-- 20. Identificador del artista que dirigió más películas

SELECT director_id, COUNT(*)
FROM movies
GROUP BY director_id
HAVING COUNT(*) >= ALL (
	SELECT COUNT(*)
	FROM movies
	GROUP BY director_id
);

-- 21. Todos los datos del artista que dirigió más películas

SELECT a.*, COUNT(*)
FROM movies m, artists a
WHERE m.director_id=a.artist_id
GROUP BY a.artist_id, a.name, a.country, a.born_date
HAVING COUNT(*) >= ALL (
	SELECT COUNT(*)
	FROM movies
	GROUP BY director_id
);

-- La función CURRENT_DATE() devuelve la fecha del sistema

-- La función TIMESTAMPDIFF(unit,date1,date2) devuelve la diferencia entre dos fechas/horas
-- El parámetro unit puede ser SECOND, MINUTE, HOUR, DAY, MONTH y YEAR
-- Si date1 es menor que date2 devuelve un valor positivo

-- 22. Todos los datos de los artistas junto con su edad actual

SELECT *, TIMESTAMPDIFF(YEAR,born_date,CURRENT_DATE())
FROM artists
WHERE dead_date IS NOT NULL;

-- 23. Todos los datos de los artistas con edad inferior a la media

SELECT *, TIMESTAMPDIFF(YEAR,born_date,CURRENT_DATE())
FROM artists
WHERE dead_date IS NOT NULL 
AND TIMESTAMPDIFF(YEAR,born_date,CURRENT_DATE()) < (
	SELECT AVG(TIMESTAMPDIFF(YEAR,born_date,CURRENT_DATE()))
	FROM artists
	WHERE dead_date IS NOT NULL
);

-- 24. Diferencia de edad en años entre Al Pacino y Robert de Niro

SELECT TIMESTAMPDIFF(YEAR,a1.born_date,a2.born_date)
FROM artists a1, artists a2
WHERE a1.name='Al Pacino' AND a2.name='Robert de Niro';

-- 25. Edad de Clint Eastwood cuando dirigió 'Million dollar baby'

SELECT m.release_year-YEAR(a.born_date)
FROM movies m, artists a
WHERE m.director_id=a.artist_id
AND a.name='Clint Eastwood'
AND m.title='Million dollar baby';

-- 26. Todos los datos del reparto de la película más antigua

SELECT *
FROM artists
WHERE artist_id IN (
	SELECT artist_id
	FROM art_mov
	WHERE movie_id IN (
		SELECT movie_id
		FROM movies
		WHERE release_year <= ALL (
			SELECT release_year
			FROM movies
		)
	)
);

-- 27. Todos los datos del estudio de la película más reciente

SELECT *
FROM studios
WHERE studio_id IN (
	SELECT studio_id
	FROM movies
	WHERE release_year <= ALL (
		SELECT release_year
		FROM movies
	)
);

-- 28. Identificadores de estudios donde hayan actuado más de 
-- cinco artistas distintos

SELECT m.studio_id, COUNT(DISTINCT am.artist_id)
FROM movies m, art_mov am
WHERE m.movie_id=am.movie_id
GROUP BY m.studio_id
HAVING COUNT(DISTINCT am.artist_id)>3;

-- 29. Lo mismo pero que aparezca el nombre del estudio

SELECT m.studio_id, s.name, COUNT(DISTINCT am.artist_id)
FROM studios s, movies m, art_mov am
WHERE s.studio_id=m.studio_id AND m.movie_id=am.movie_id
GROUP BY m.studio_id, s.name
HAVING COUNT(DISTINCT am.artist_id)>3;

----------------------------------------------------------
-------------- Subconsultas Correlacionadas --------------
----------------------------------------------------------
-- Hay una correlación entre la subconsulta y la consulta.
-- La subconsulta usa un campo de la consulta principal.
-- Una subconsulta 'normal' sólo se ejecuta una vez.
-- La subconsulta correlacionada se ejecuta una vez para
-- cada fila de la consulta principal.

-- 30. Para cada identificador de estudio, la película más reciente

SELECT *
FROM movies m1
WHERE release_year=(
	SELECT MAX(release_year)
	FROM movies m2
	WHERE m1.studio_id=m2.studio_id
);

-- 31. Lo mismo de antes sin usar MAX y usando ALL

SELECT *
FROM movies m1
WHERE release_year >= ALL (
	SELECT release_year
	FROM movies m2
	WHERE m1.studio_id=m2.studio_id
);

-- 32. Lo mismo de antes pero con el nombre del estudio

SELECT *
FROM studios s, movies m1
WHERE s.studio_id=m1.studio_id
AND release_year >= ALL (
	SELECT release_year
	FROM movies m2
	WHERE m1.studio_id=m2.studio_id
);

-- 33. Para cada identificador de película, el actor más joven
-- Es necesaria una subconsulta correlacionada
-- La película de la consulta es igual a la película de la subconsulta

SELECT *
FROM art_mov am1, artists a1
WHERE am1.artist_id=a1.artist_id
AND a1.born_date >= ALL (
	SELECT born_date
	FROM art_mov am2, artists a2
	WHERE am2.artist_id=a2.artist_id
	AND am1.movie_id=am2.movie_id  
);

-- 34. A lo anterior añadir el título de la película

SELECT m.movie_id, m.title, a1.*
FROM movies m, art_mov am1, artists a1
WHERE m.movie_id=am1.movie_id AND am1.artist_id=a1.artist_id
AND a1.born_date >= ALL (
	SELECT born_date
	FROM art_mov am2, artists a2
	WHERE am2.artist_id=a2.artist_id
	AND am1.movie_id=am2.movie_id  
);

-- 35. Para cada actor, su identificador y título de su primera película
-- Se necesita una subconsulta correlacionada
-- El artista de la consulta es igual al artista de la subconsulta

SELECT  am1.artist_id, m1.title
FROM movies m1, art_mov am1
WHERE m1.movie_id=am1.movie_id
AND m1.release_year <= ALL (
	SELECT release_year
	FROM movies m2, art_mov am2
	WHERE m2.movie_id=am2.movie_id
	AND am1.artist_id=am2.artist_id -- Correlación 
);

-- 36. A lo anterior añadir el nombre del actor

SELECT am1.artist_id, a.name, m1.title
FROM movies m1, art_mov am1, artists a
WHERE am1.artist_id=a.artist_id
AND m1.movie_id=am1.movie_id
AND m1.release_year <= ALL (
	SELECT release_year
	FROM movies m2, art_mov am2
	WHERE m2.movie_id=am2.movie_id
	AND am1.artist_id=am2.artist_id -- Correlación 
);

--37.Para casa artista (que salgan todos) todos sus datos de peliculas dirigidas 
SELECT a.artist_id,a.name,a.country,a.born_date,COUNT(m.director_id)
FROM artists a LEFT JOIN movies m ON a.artist_id=m.director_id
GROUP BY a.artist_id,a.name,a.country,a.born_date;

--38. Para cada estudio, todos sus datos y numero de peliculas
SELECT s.studio_id,s.name,s.fundation_year,COUNT(m.movie_id)
FROM studios s LEFT JOIN movies m ON s.studio_id=m.studio_id
GROUP BY s.studio_id,s.name,s.fundation_year;

--39. Para cada artista, todos sus datos y numero de peliculas
SELECT a.artist_id,a.name,a.country,a.born_date COUNT(am.artist_id)
FROM artists a LEFT JOIN art_mov am ON a.artist_id=am.artist_id
GROUP BY a.artist_id,a.name,a.country,a.born_date;

-- 40. Todos los datos de películas donde Elijah Wood fuera menor de 20 años (aprox)

SELECT * 
FROM movies
WHERE movie_id IN (
	SELECT movie_id
	FROM art_mov
	WHERE artist_id = (
		SELECT artist_id
		FROM artists
		WHERE name='Elijah Wood'
	)
)
AND release_year <= (
	SELECT YEAR(born_date)+20
	FROM artists
	WHERE name='Elijah Wood'
);

-- 41. Para cada artista (que salgan todos), todos sus datos, número de 
-- películas dirigidas y porcentaje respecto al total de películas (37)

SELECT a.*, 
COUNT(m.movie_id) AS count_movies, COUNT(m.movie_id)/s.num_movies*100 AS porc_movies
FROM artists a LEFT JOIN movies m ON a.artist_id=m.director_id, (
	SELECT COUNT(*) AS num_movies
	FROM movies
) s
GROUP BY a.artist_id, a.name, a.country, a.born_date, s.num_movies;

-- 42. Para cada estudio (que salgan todos), todos sus datos, número de
-- películas y porcentaje respecto al total de películas (38)

SELECT s.studio_id, s.name, s.fundation_year, 
COUNT(m.movie_id) AS count_movies, COUNT(m.movie_id)/s.num_movies*100 AS porc_movies
FROM studios s LEFT JOIN movies m ON s.studio_id=m.studio_id, (
	SELECT COUNT(*) AS num_movies
	FROM movies
) s
GROUP BY s.studio_id, s.name, s.fundation_year;

-- 43. Para cada artista (que salgan todos), todos sus datos, número de
-- películas en las que actúa y porcentaje respecto al total de películas (39)

SELECT a.artist_id, a.name, a.country, a.born_date, 
COUNT(am.artist_id) AS num_movies, COUNT(am.artist_id)/s.num_movies*100
FROM artists a LEFT JOIN art_mov am ON a.artist_id=am.artist_id, (
	SELECT COUNT(*) AS num_movies
	FROM movies
) s
GROUP BY a.artist_id, a.name, a.country, a.born_date;

-- 44. Para cada década (20, 30, 40, etc), número de artistas 

SELECT	IF(YEAR(born_date)<1950,'40',
			IF(YEAR(born_date)<1960,'50',
				IF(YEAR(born_date)<1970,'60',
					IF(YEAR(born_date)<1980,'70',
						IF(YEAR(born_date)<1990,'80',
							IF(YEAR(born_date)<2000,'90',
								IF(YEAR(born_date)<2010,'00','10'))))))) AS decade, COUNT(*)
FROM artists
GROUP BY IF(YEAR(born_date)<1950,'40',
			IF(YEAR(born_date)<1960,'50',
				IF(YEAR(born_date)<1970,'60',
					IF(YEAR(born_date)<1980,'70',
						IF(YEAR(born_date)<1990,'80',
							IF(YEAR(born_date)<2000,'90',
								IF(YEAR(born_date)<2010,'00','10')))))));
-- 1. las piezas de Mozart.
SELECT*
FROM pieces
WHERE composer_id IN(
	SELECT composer_id
	FROM composers
	WHERE name='Mozart'
);
-- 2. Todos los datos de las piezas de Mozart que se hayan tocado en el año 2020.

SELECT*
FROM pieces
WHERE composer_id IN(
	SELECT composer_id
	FROM composers
	WHERE name='Falla'
)
AND piece_id IN(
	SELECT piece_id
	FROM con_per
	WHERE concert_id IN(
		SELECT concert_id
		FROM concerts
		WHERE YEAR(concert_date)=2019
		)
);

-- 3. Todos los datos de intérpretes que nunca han tocado piezas de Mozart.
SELECT*
FROM performers
WHERE performer_id NOT IN(
	SELECT performer_id
	FROM con_per
	WHERE piece_id IN(
		SELECT piece_id
		FROM pieces
		WHERE composer_id =(
			SELECT composer_id
			FROM composers
			WHERE name LIKE 'Mozart'
			)
		)
)
-- 4. Todos los datos del compositor más antiguo.
SELECT*
FROM composers
WHERE born_date =(
	SELECT MIN(born_date)
	FROM composers
);

-- 5. Todos los datos del compositor con más piezas.
SELECT c.*,COUNT(*)
FROM composers c,pieces p
WHERE c.composer_id=p.composer_id
GROUP BY c.composer_id,c.name,c.country,c.born_date,c.death_date
HAVING COUNT(*)>= ALL (
	SELECT COUNT(*)
	FROM pieces
	GROUP BY composer_id
);
-- 6. Para cada auditorio, todos sus datos, número de conciertos y suma de público.
SELECT auditorium,COUNT(*) AS num_concerts,SUM(people)AS sum_people
FROM concerts
GROUP BY auditorium;

-- 7. Todos los datos del auditorio con más suma de público.
SELECT auditorium,COUNT(*) AS num_concerts,SUM(people)AS sum_people
FROM concerts
GROUP BY auditorium;
HAVING SUM (people) >= ALL (
	SELECT SUM (people)
	FROM concerts
	GROUP BY auditorium
);
-- 8. Todos los datos de violinistas que tocaron en la Casa Colón, sin duplicados.
SELECT*
FROM performers
WHERE performer_id IN(
	SELECT performer_id
	FROM per_con
	WHERE instrument='Violin'
	AND concert_id IN(
		SELECT concert_id
		FROM concerts
		WHERE auditorium='Casa Colon'
		)
)
-- 9. Número de violinistas distintos que tocaron en la Casa Colón.

SELECT COUNT(DISTINCT performer_id)
FROM per_con
WHERE instrument='Violin'
AND concert_id IN (
	SELECT concert_id
	FROM concerts
	WHERE auditorium='Casa Colón'
);

-- 10. Para cada intérprete, todos sus datos y número de instrumentos distintos que toca.

SELECT p.performer_id, p.name, COUNT(DISTINCT instrument)
FROM performers p, per_con pc
WHERE p.performer_id=pc.performer_id
GROUP BY p.performer_id, p.name;

-- 11. Identificador de los intérpretes que hayan tocado en todos los conciertos.

SELECT performer_id, COUNT(*)
FROM per_con
GROUP BY perforner_id
HAVING COUNT(*) = (
	SELECT COUNT(*)
	FROM concerts
);

-----------------------------------------------------
--------------- La clausula JOIN --------------------
-----------------------------------------------------

-- Es una sintaxis más formal de hacer un equijoin
-- FROM <tabla_padre> JOIN <tabla_hija> ON <clave_primaria>=<clave_ajena>

-- 12. Equijoin de compositores y piezas

SELECT *
FROM composers c JOIN pieces p 
ON c.composer_id=p.composer_id;

-----------------------------------------------------
----------- Equi-join externo o Left-join -----------
-----------------------------------------------------

-- En el resultado aparecen las filas de la tabla padre
-- que no se han emparejado por no tener hijos.
-- Se usa LEFT antes de JOIN

-- 13. Left-join de compositores y piezas

SELECT *
FROM composers c LEFT JOIN pieces p 
ON c.composer_id=p.composer_id;

-- 14. Para cada compositor (que salgan todos), todos sus datos y número de piezas

SELECT c.*, COUNT(p.piece_id)
FROM composers c LEFT JOIN pieces p 
ON c.composer_id=p.composer_id
GROUP BY c.composer_id,c.name,c.born_date,c.death_date,c.country;

-- 15. Para cada intérprete (que salgan todos), todos sus datos, número de conciertos,
-- y número de instrumentos distintos que toca

SELECT p.*, COUNT(DISTINCT concert_id), COUNT(DISTINCT instrument)
FROM performers p LEFT JOIN per_con pc
ON p.performer_id=pc.performer_id
GROUP BY p.performer_id, p.name, p.email, p.phone, p.born_date;

-- 16. Para cada pieza musical (que salgan todas), todos sus datos y número de conciertos

SELECT p.*, COUNT(DISTINCT concert_id)
FROM pieces p LEFT JOIN per_con pc
ON p.piece_id=pc.piece_id
GROUP BY p.piece_id, p.title, p.gender, p.composer_id;

--17.Para cada sede, suma de publico y porcentaje respecto al publico total

SELECT  c.auditorium, SUM(c.people), SUM(c.people)/s.sum_people*100
FROM concerts c,(
	SELECT SUM(people) AS sum_people
	FROM concerts
)s
GROUP BY c.auditorium

--18. Crea una tabla auxiliar con tres compositores y luego inserta mediante una consulta todos esos datos

CREATE TABLE com_aux(
	na VARCHAR(30),
	co VARCHAR(30),
	bo DATE,
	de DATE
);

INSERT INTO com_aux (

);

--19. Para cada compositor (que salgan todos), todos sus datos, numero de piezas musicales y porcentajes de piezas 
--con respecto al total de piezas

SELECT c.*,COUNT(p.piece_id) AS num_pieces
FROM composers c 
LEFT JOIN pieces p
ON c.composer_id=p.composer_id
GROUP BY c.composer_id,c.name,c.country,c.born_date,c.death_date



--20. Para cada compositor. siglo de nacimiento 


--21. Para cada siglo, numero de compositores 

--22. Edad de Johann Strauss padre cuando nacio Johann Strauss hijos

--23.

--24. Suma de publico del Gran Teatro menos suma de publico de la Casa Colon
SELECT SUM(people)
FROM concerts
WHERE auditorium="Casa Colon";

-- Esto da 2033

SELECT SUM(people)
FROM concerts
WHERE auditorium='Gran Teatro'

--Esto da 780
SELECT 2033-780;

--Esto da 1253

SELECT s1.suma-s2.suma
FROM(
	SELECT SUM(people)
FROM concerts
WHERE auditorium="Casa Colon"
) s1, (
	SELECT SUM(people)
FROM concerts
WHERE auditorium='Gran Teatro'
)s2;


--25. Dias transcurridos entre los dos ultimos conciertos de la Casa Colon

-- La fecha del el ultimo concierto de la Casa Colon

SELECT MAX(concert_date)
FROM concerts
WHERE auditorium="Casa Colon"

--La fecha del penultimo concierto de la Casa Colon

SELECT MAX(concert_date)
FROM concerts
WHERE auditorium='Casa Colón'
AND concert_date <> (
	SELECT MAX(concert_date)
	FROM concerts
	WHERE auditorium='Casa Colón'
);

-- Esto da 2019-12-22

-- Lo ponemos todo junto usando subconsultas en FROM

SELECT TIMESTAMPDIFF(DAY,date2,date1) 
FROM (
	SELECT MAX(concert_date) AS date1
	FROM concerts
	WHERE auditorium='Casa Colón'
) s1, (
	SELECT MAX(concert_date) AS date2
	FROM concerts
	WHERE auditorium='Casa Colón'
	AND concert_date <> (
		SELECT MAX(concert_date)
		FROM concerts
		WHERE auditorium='Casa Colón'
	)
) s2;

-- 26. La edad de Beethoven cuando murió Mozart

SELECT TIMESTAMPDIFF(YEAR,s1.born_date,s2.death_date)
FROM (
	SELECT born_date
	FROM composers
	WHERE name LIKE '%Beethoven%'
) s1, (
	SELECT death_date
	FROM composers
	WHERE name LIKE '%Mozart%'
) s2;

-- 27. Compositores contemporáneos de Tchaikovsky

SELECT *
FROM (
	SELECT born_date, death_date
	FROM composers
	WHERE name='Tchaikovsky, Piotr Ilich'
) t, composers c
WHERE NOT (c.death_date < t.born_date
OR c.born_date > t.death_date);

-- 28. Compositores no contemporáneos de Tchaikovsky

SELECT *
FROM (
	SELECT born_date, death_date
	FROM composers
	WHERE name='Tchaikovsky, Piotr Ilich'
) t, composers c
WHERE c.death_date < t.born_date
OR c.born_date > t.death_date;

-- 1. Todos los datos de los vehículos blancos o grises que
-- entraron el día 01-10-2018

SELECT *
FROM vehicle
WHERE color IN ('Blanco','Gris')
AND vehicle_id IN (
	SELECT vehicle_id
	FROM stay
	WHERE in_date='2018-10-01'
);

-- No sale ninguno porque el campo in_date es DATETIME
-- La función DATE() devuelve la fecha de un DATETIME

SELECT *
FROM vehicle
WHERE color IN ('Blanco','Gris')
AND vehicle_id IN (
	SELECT vehicle_id
	FROM stay
	WHERE DATE(in_date)='2018-10-01'
);

-- 2. Para cada marca, número de vehículos y número de estancias

SELECT mark, COUNT(DISTINCT v.vehicle_id), COUNT(*)
FROM vehicle v, stay s
WHERE v.vehicle_id=s.vehicle_id
GROUP BY mark;


--3.Para cada matricula(todas), numero de entradas y numero de salidas

SELECT v.vehicle_id,COUNT(in_date), COUNT(out_date)
FROM vehicles v, LEFT JOIN stay s
ON v.vehicle_id;

--4.Todos los datos de los vehiculos que estan actualmente estacionados junto con el tiempo en minutos que llevan

SELECT v.*,in_date, TIMESTAMPDIFF(MINUTE, in_date, CURRENT_TIMESTAMP()) AS MINUTE
FROM vehicles v, stay s
WHERE v.vehicle_id=s.vehicle_id
AND out_date IS NULL;

--5.Para cada dia y cada planta, numero de entradas y salidas

SELECT DATE(in_date), place_floor, COUNT(in_date), COUNT(out_date)
FROM stay s, place c
WHERE s.place_id=c.place_id
GROUP BY DATE(in_date), place_floor;

-- 6. Para cada día y cada planta, número de entradas, porcentaje
-- de entradas respecto al total de entradas, número de salidas y
-- porcentaje de salidas respecto al total de salidas

SELECT DATE(in_date), place_floor, 
COUNT(in_date) AS num_entradas, COUNT(in_date)/v.count_in*100 AS por_entradas
COUNT(out_date) AS num_salidas, COUNT(out_date)/v.count_out*100 AS por_salidas
FROM stay s, place c, (
	SELECT COUNT(in_date) AS count_in, COUNT(out_date) AS count_out
	FROM stay
) v
WHERE s.place_id=c.place_id
GROUP BY DATE(in_date), place_floor;
--7.Todos los datos de las estancias y los precios por dia y minuto
-- En el último tramo de precios (el vigente actualmente), hay que sustituir
-- el valor NULL de la columna until_date por la fecha actual.
-- De lo contrario, las estancias más recientes no se emparejan.

SELECT*
FROM stay s. price p
WHERE s.in_date BETWEEN p.from_date AND p.until_date;

--8.La marca de vehiculo que mas estancias tiene
SELECT mark, COUNT(*)
FROM vehicle v, stay s
WHERE v.vehicle_id=s.vehicle_id
GROUP BY mark
HAVING COUNT(*) >= ALL (
	SELECT COUNT(*)
	FROM vehicle v, stay s
	WHERE v.vehicle_id=s.vehicle_id
	GROUP BY mark
);

--9. Todos los datos de las estancias junto con su duracion en min

SELECT *, TIMESTAMPDIFF(MINUTE,in_date,out_date) AS duration
FROM stay;

--10. Teniendo en cuenta que un dia tiene 1440 minutos, calcula el numero de dias y de minutos de cada estancia
--La funcion MOD y el operador % calculan el resto de la division 

SELECT*, TIMESTAMPDIFF(MINUTE, in_date,out_date) AS duration_minutes,
TIMESTAMPDIFF(DAY, in_date, out_date) AS duration_days,
MOD(TIMESTAMPDIFF(MINUTE, int_date, out_date),1440) AS resto1,
TIMESTAMPDIFF(MINUTE, int_date,out_date)%1440 AS resto2
FROM stay;


--11. Calcula el importe de cada estancia

SELECT*, 
TIMESTAMPDIFF(DAY, in_date,out_date) AS duration_days,
MOD(TIMESTAMPDIFF(MINUTE, in_date, out_date),1440 AS resto,
TIMESTAMPDIFF(DAY,in_date,out_date)*price_day AS import_days,
MOD(TIMESTAMPDIFF(MINUTE, int_date, out_date),1440)*price_minute AS import_minutes,
FROM stay s,price p
WHERE s.in_date BETWEEN p.from_date AND p.until_date;


--12. Recalcula el importe de las estancias teniendo en cuenta que no se porque puede
--cobrar 
SELECT *,
TIMESTAMPDIFF(DAY,in_date,out_date) AS duration_days,
MOD(TIMESTAMPDIFF(MINUTE,in_date,out_date),1440) AS resto,
TIMESTAMPDIFF(DAY,in_date,out_date)*price_day AS import_days,
IF(MOD(TIMESTAMPDIFF(MINUTE,in_date,out_date),1440)*price_minute>price_day,
price_day,MOD(TIMESTAMPDIFF(MINUTE,in_date,out_date),1440)*price_minute) AS import_minutes,
TIMESTAMPDIFF(DAY,in_date,out_date)*price_day +
IF(MOD(TIMESTAMPDIFF(MINUTE,in_date,out_date),1440)*price_minute>price_day,
price_day,MOD(TIMESTAMPDIFF(MINUTE,in_date,out_date),1440)*price_minute) AS import_total
FROM stay s, price p
WHERE s.in_date BETWEEN p.from_date AND IFNULL(p.until_date,CURRENT_DATE);

--13.Para cada estancia, calcula la columna Duration con el siguiente valor:
--Long en estancias de mas de 100 minutos
--Short en estancias de menos de 100 minutos

SELECT*, IF(TIMESTAMPDIFF(MINUTE,int_date,out_date)>100,'Long','Short')AS duration
FROM stay;

--14.Repite la consulta anterior pero con el valor "medium" para estancias
-- comprendidas entre 80 y 100 minutos

SELECT*, IF(TIMESTAMPDIFF(MINUTE,int_date,out_date)>100,'Long',
			IF(TIMESTAMPDIFF(MINUTE,int_date,out_date)>80,'Medium','Short')AS duration
FROM stay;

--15.Repite la consulta anterior utilizando el operador <(less than)
SELECT*, IF(TIMESTAMPDIFF(MINUTE,int_date,out_date)<100,'Long',
			IF(TIMESTAMPDIFF(MINUTE,int_date,out_date)<80,'Medium','Short')AS duration
FROM stay;

--16.Todos los datos de la tabla vehiculos junto con una columna que muestra si el vehiculo es aleman o del resto del mundo

SELECT* IF(mark IN ('Mercedes','BMW')AS pais
FROM vehicle;

--17.Vehiculos para los que no hay ninguna estancia

SELECT*
FROM vehicle
WHERE vehicle_id NOT IN (
	SELECT vehicle_id
	FROM stay
);

--18.Para cada plaza,numero de estancias y porcentaje respecto al total
--Que aparezcan todas las plazas

SELECT p.place_id,COUNT(s.stay.id), COUNT(s.stay_id)/num_places*100
FROM place p LEFT JOIN stay s
ON p.place_id=s.place_id,(
	SELECT COUNT(*)
	FROM stay
)t;
GROUP BY p.place_id;

--19.Tiempo en minutos que estuvo ocupada cada plaza (que salgan todos)
SELECT p.place_id,SUM(TIMESTAMPDIFF(MINUTE,in_date,out_date)) AS suma
FROM place p LEFT JOIN stay s
ON p.place_id=s.place_id,(
	SELECT COUNT(*)
	FROM stay
)t;
GROUP BY p.place_id;

--20.Minutos de ocupacion el dia 3 de octubre de 2018

-- Suma de minutos de ocupación el día 3 de octubre de 2018

-- Porcentaje de ocupación el día 3 de octubre de 2018

-- En la consulta anterior, el número de plazas es 8
-- Podemos obtener este valor mediante una consulta
-- y guardarlo en una variable para su uso posterior


-- Para cada marca con más de 4 vehículos, número de vehículos

-- Para cada vehículo con más de una entrada,
-- número de entradas y número de salidas

SELECT vehicle_id, COUNT(in_date), COUNT(out_date)
FROM stay
GROUP BY vehicle_id 
HAVING COUNT(in_date)>1

--23.Todos los dtos del vehiculo que mas entradas tiene
SELECT v.*,COUNT(*)
FROM vehicle v,stay s
WHERE v.vehicle_id=s.vehicle_id
GROUP BY v.vehicle_id,v.mark,v.model,v.color
HAVING COUNT(*) >= ALL(
	SELECT COUNT(*)
	FROM stay
	GROUP vehicle_id
);

--24. Para cada vehiculo su estancia mas larga(Correlacionada)

SELECT vehicle_id, TIMESTAMPDIFF(MINUTE,in_date,IFNULL(out_date,CURRENT_DATE)
FROM stay s1
WHERE TIMESTAMPDIFF(MINUTE,in_date,IFNULL(out_date,CURRENT_DATE))>= ALL(
	SELECT MAX(TIMESTAMPDIFF(MINUTE,in_date,IFNULL(out_date,CURRENT_DATE)))
	FROM stay s2
	WHERE s1.vehicle_id=s2.vehicle_id
);

--25.Para cada plaza, su identificador y su estancia mas corta
SELECT*
FROM place
WHERE place_id IN(
	SELECT place_id
	FROM stay
	WHERE vehicle_id IN (
		SELECT vehicle_id
		WHERE mark='Opel' AND model='Astral'
		)
);


--26.Para cada pieza, matricula del vehiculo que la ocupa ahora

SELECT*
FROM vehicle
WHERE vehicle_id NOT IN(
	SELECT vehicle_id
	FROM stay
	WHERE place_id IN(
		SELECT place_id
		FROM place
		WHERE place_floor=
		)
)

--Si la plaza esta vacia, que aparezca la palabra empty

--27.Estancias mas cortas que la media. Supongamos que hoy es 10/10/2018

SELECT AVG(TIMESTAMPDIFF(in_date),IFNULL(out_date,'2018-10-10')))
FROM stay
WHERE TIMESTAMPDIFF(MINUTE,in_date,IFNULL(out_date,'2018-10-10'))< (
	SELECT AVG(TIMESTAMPDIFF(MINUTE,in_date,IFNULL(out_date,'2018-10-10')))
	FROM stay
)

--28-Vehiculo con mayor numero de minutos
--29-Dia con mayor numero de entradas
--30-Las estancias 9 y 24 son del mismo vehiculo. Minutos que estuvo fuera
--31-Incremento de precio del dia desde el 01/02/2017 hasta 01/02/2018
--32-Facturacion diaria (suma de importes cobrados a la salida)
--33-El vehiculo  0987-BSR  aparca en la primera plaza libre
--34-Los precios suben a partir de hoy un 2.5%

--Modificar el ultimo registro de precios
--Insertar un nuevo registro de precios